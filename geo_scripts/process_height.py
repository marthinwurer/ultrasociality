import os

import gdal
import georasters as gr
import matplotlib.pyplot as plt
import numpy as np
from affine import Affine
from rasterstats.io import Raster, read_features
from rasterstats.utils import boxify_points, rasterize_geom
from shapely.geometry import shape

"""
Split into 1 degree grid. Get standard deviation, average elevation, and land %. 
"""

def round_to_nearest(val, nearest):
    return round(val * nearest) / nearest


def map_indexes(raster, point_x, point_y):
    row, col = gr.map_pixel(point_x, point_y,
                         raster.x_cell_size, raster.y_cell_size, raster.xmin, raster.ymax)
    return row, col


def map_indexes_geot(geot, point_x, point_y):
    row, col = gr.map_pixel(point_x, point_y,
                            geot[1], geot[-1], geot[0], geot[3])
    return row, col



def aggregate_grid(raster: gr.GeoRaster, x_ranges, y_ranges, func=np.ma.mean):
    """
    aggregate an image by rectangles. these rectangles are generated by all pairs of x and y edges.
    Args:
        raster: a georaster
        x_ranges: the north edge of the rectangles to aggregate by
        y_ranges: the west edge of the rectangles to aggregate by
        func: the aggregation function to use. defaults to average.
    """
    shape = raster.shape
    y_steps = len(y_ranges)
    x_steps = len(x_ranges)

    output = np.ma.zeros((y_steps, x_steps))

    for y_step, y_range in enumerate(y_ranges):
        for x_step, x_range in enumerate(x_ranges):
            # row, col: row is y, col is x
            north, west = map_indexes(raster, x_range[0], y_range[0])
            south, east = map_indexes(raster, x_range[1], y_range[1])
            if west < 0:
                west = 0
            if north < 0:
                north = 0

            if south >= 0 and east >= 0:
                # normal path
                im_slice = raster.raster[north:south, west:east]
                val = func(im_slice)
                output[y_step, x_step] = val
            else:
                # if outside bounds, mask it
                output[y_step, x_step] = np.ma.masked

    return output


def aggregate_globe_with_geot(raster, geot, func=np.ma.mean, step=1):
    x_ranges = list(gen_ranges(-180, 180, step))
    y_ranges = list(gen_ranges(90, -90, step))
    y_steps = len(y_ranges)
    x_steps = len(x_ranges)

    output = np.ma.zeros((y_steps, x_steps))

    for y_step, y_range in enumerate(y_ranges):
        for x_step, x_range in enumerate(x_ranges):
            # row, col: row is y, col is x
            north, west = map_indexes_geot(geot, x_range[0], y_range[0])
            south, east = map_indexes_geot(geot, x_range[1], y_range[1])
            if west < 0:
                west = 0
            if north < 0:
                north = 0

            if south >= 0 and east >= 0:
                # normal path
                im_slice = raster[north:south, west:east]
                val = func(im_slice)
                output[y_step, x_step] = val
            else:
                # if outside bounds, mask it
                output[y_step, x_step] = np.ma.masked

    return output


def get_slices(raster, x_ranges, y_ranges):
    out = []
    for y_step, y_range in enumerate(y_ranges):
        row = []
        for x_step, x_range in enumerate(x_ranges):
            # row, col: row is y, col is x
            north, west = map_indexes(raster, x_range[0], y_range[0])
            south, east = map_indexes(raster, x_range[1], y_range[1])
            if west < 0:
                west = 0
            if north < 0:
                north = 0

            if south >= 0 and east >= 0:
                # normal path
                im_slice = raster.raster[north:south, west:east]
            else:
                im_slice = None
            row.append(im_slice)
        out.append(row)
    return out


def aggregate_slices(slices, how=np.ma.mean):
    output = np.ma.zeros((len(slices), len(slices[0])))
    for y_step, row in enumerate(slices):
        for x_step, im_slice in enumerate(row):
            if im_slice is not None:
                val = how(im_slice)
                output[y_step, x_step] = val
            else:
                output[y_step, x_step] = np.ma.masked
    return output


def filter_masked(data):
    if np.mean(data.mask) > 0.65:
        return np.ma.masked
    else:
        return np.ma.mean(data)


def gen_ranges(start, finish, step):
    total_range = finish - start
    if total_range < 0:
        step *= -1
        total_range = abs(total_range)
    num = int(total_range / abs(step))
    vals = [start + i * step for i in list(range(num + 1))]
    first = vals[:-1]
    second = vals[1:]

    return zip(first, second)


def br_wrapper(raster, x_deg, y_deg, how=np.ma.mean):
    """
    reduce a georaster with pixel sizes of x_deg by y_deg
    """
    (xmin, xsize, x, ymax, y, ysize) = raster.geot
    x_block = int(abs(x_deg / xsize))
    y_block = int(abs(y_deg / ysize))
    block_size = (x_block, y_block)
    # clip the raster so there's no overlap
    # if raster.shape[0] % y_block != 0 or raster.shape[1] % x_block != 0:
    #     array =
    output = raster.block_reduce(block_size, how=how)
    return output


def clip_gr(raster: gr.GeoRaster):
    """ Take a georaster and get a slice without a pesky edge """
    data = raster.raster[:-1,:-1]
    new_raster = gr.GeoRaster(data, raster.geot, raster.nodata_value,
                              projection=raster.projection, datatype=raster.datatype)
    return new_raster


def rasterize_shapefile(shapes, raster, band=1, layer=0, all_touched=False):
    data = raster.raster
    geot = raster.geot
    nodata = raster.nodata_value

    affine = Affine.from_gdal(*geot)
    rast = Raster(data, affine, nodata, band)
    out = np.zeros(data.shape, dtype=np.bool)
    features_iter = read_features(shapes, layer)
    for _, feat in enumerate(features_iter):
        geom = shape(feat['geometry'])

        if 'Point' in geom.type:
            geom = boxify_points(geom, rast)

        # rasterized geometry
        rv_array = rasterize_geom(geom, like=rast, all_touched=all_touched)
        out |= rv_array

    return out


def get_global_raster(scale):
    shape = np.asarray([180, 360]) * scale
    base = np.ma.ones(shape)
    desired_x_size = 360 / base.shape[1]
    desired_y_size = 180 / base.shape[0]

    geot = (-180.0, desired_x_size, 0.0, 90.0, 0.0, -desired_y_size)
    (xmin, xsize, x, ymax, y, ysize) = geot
    raster = gr.GeoRaster(base, geot, nodata_value=0.0, fill_value=0.0,
                          projection="+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs")
    return raster




# def index_to_lat_long()

def main():
    # DATA = "../data/relief_san_andres.tif"
    DATA = "~/Downloads/datasets/elevation/viewfinder_dem3/15-J.tif"  # from http://www.viewfinderpanoramas.org/dem3.html
    DATA = os.path.expanduser(DATA)

    data = gr.from_file(DATA)
    (xmin, xsize, x, ymax, y, ysize) = data.geot
    print(data.geot)
    NDV, xsize, ysize, GeoT, Projection, DataType = gr.get_geo_info(DATA)
    print(NDV, xsize, ysize, GeoT, DataType)
    print(Projection)

    # ok, when looking again it looks like the max and min are the edges + half the difference.
    # I might just try indexing for regions that are a multiple of the dimensions into the raster.

    # find top coords of grid cell in map for lat/long
    dx = 1.0  # in degrees
    dy = 1.0  # in degrees
    nw_corner = (round_to_nearest(xmin, dx), round_to_nearest(ymax, dy))
    print(nw_corner)
    se_corner = (round_to_nearest(nw_corner[0]+dx, dx), round_to_nearest(nw_corner[1]-dy, dy))
    print(se_corner)
    # data.plot()
    # plt.show()

    # get the array indexes for the map
    print(type(data.raster))
    print(data.raster.shape)
    print(data.raster)

    print(GeoT)
    x_indexes = int(dx / GeoT[1])
    y_indexes = int(dy / -GeoT[5])
    print(x_indexes, y_indexes)


    # determine the desired final raster size.

    # wait, i want to figure out how to divide this up to give each chunk its own list of data to take stats on
    # so I need to determine the next chunk. Or just iterate through the whole damn image and append the values to
    # a dict for that chunk
    # yeah let's do that, it's easy.

    # lol never mind just get the map pixels for the corners and iterate over them
    # col, row = gr.map_pixel(x,y,GeoT[1],GeoT[-1], GeoT[0],GeoT[3])
    # col, row = gr.map_pixel()
    print(data.map_pixel_location(13, 13))
    row, col = data.map_pixel_location(13,13)
    print(row, col)




if __name__ == "__main__":
    main()
